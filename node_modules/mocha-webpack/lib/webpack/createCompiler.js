'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = createCompiler;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _webpack = require('webpack');

var _webpack2 = _interopRequireDefault(_webpack);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var missing = function missing() {
  (0, _invariant2.default)(false, 'parameters are missing');
};

function createCompiler(webpackConfig) {
  var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : missing();

  (0, _invariant2.default)(_lodash2.default.isPlainObject(webpackConfig), 'webpackConfig must be a plain object');
  (0, _invariant2.default)(_lodash2.default.isFunction(cb), 'cb must be a function');

  var compiler = (0, _webpack2.default)(webpackConfig);

  var failedModules = [];
  var failedModulesErrors = [];

  compiler.plugin('failed', cb);

  compiler.plugin('compilation', function (compilation) {
    // Workaround to tag build as failed when webpack marks a failed module as just a warning
    compilation.plugin('build-module', function (module) {
      var ident = module.identifier();

      if (ident) {
        var idx = failedModules.indexOf(ident);
        if (idx !== -1) {
          failedModules.splice(idx, 1);
          failedModulesErrors.splice(idx, 1);
        }
      }
    });
    compilation.plugin('failed-module', function (module) {
      var ident = module.identifier();
      if (ident) {
        failedModules.push(ident);
        failedModulesErrors.push(module.error);
      }
    });
  });

  compiler.plugin('done', function (stats) {
    if (stats.hasErrors()) {
      var jsonStats = stats.toJson();

      var _jsonStats$errors = _slicedToArray(jsonStats.errors, 1);

      var err = _jsonStats$errors[0];

      cb(err);
    } else if (failedModulesErrors.length) {
      var _err = failedModulesErrors[0];

      cb(_err);
    } else {
      cb();
    }
  });
  return compiler;
}